#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<wait.h>

void fork_info(char arg[])
{
	//Айди текущего процесса
	printf("%i ",getpid());
	//Айди родительского процесса
	printf("%i ",getppid());
	//Айди прародительского процесса
	//Для прародителя - айди сессии, в которой он запущен
	printf("%i ",getpgid(getpid()));
	//Айди сессии - совпадает с айди консоли
	printf("%i ",getsid(getpid()));
	//Для прародителя я тут пишу название этой программы
	//Для дочерних, название программ, которые они вызовут.
	printf("%s\n",arg);
}

//В переменную argv при запуске программы мы передаём команды для вызова программ (без доп. элементов)
int main(int argc, char* argv[])
{
	//Идея алгоритма заключается в том, чтобы родительский процесс разбивать на argc-1 дочерние и пусть эти дочерние становятся вызываемыми функциями
	//Реализация лабораторной именно такая, потому что системные вызовы семейства exec полностью заменяют процесс, в котором вызываются, на процесс для выполнения передваемой программы
	// То есть читаешь Книгу1, в ней написано, "забудь об этой и читай Книгу2". Берёшь Книгу2, а Книгу1 навсегда сжигаешь.
	
	//Да, да. Дочерние процессы тут на убой, чтобы родительский мог вызвать все программы (при том последовательно)
	// Я его породил, я его и уничтожу.
	//Чтоб вы поняли: мы создаём копию Книги1 и в ней читаем строку "забудь об этой и читай Книгу2", а оригинал продолжаем читать со следующей строки, после прочтения Книги2
	int child_status;
	pid_t *child_pids, parent_pid;
	//Создаём массив для дочерних элементов размером argc (просто индексация начинаю с 1, а не с 0)
	child_pids=(int *) calloc(argc,sizeof(int));
	for(int i=1;i<argc;i++) child_pids[i]=0;
	parent_pid=(int) getpid();
	//Вызываем информацию о родительском процессе
	fork_info(argv[0]);
	for(int i=1;i<argc;i++)
	{
		child_pids[i]=fork();
		if(child_pids[i]==0)
		{
			//Информация об одном из дочерних процессов
			fork_info(argv[i]);
			//Одна из "перегрузок" семейства "ехес"
			//Подробно о том какие они бывают, если хотите могу рассказать перед парой
			//Это же "перегрузка" принимает на вход вызов функции (1-ый аргумент) и весь argv для неё до NULL (все аргументы после первого)
			//Раз уж мы подразумеваем, что доп аргументов мы писать не будем то надо передать лишь argv[0], для этой функции (в ней хранится сам вызов программы)
			//(Поэтому 1-ый и 2-ой аргументы совпадают)
			if(execlp(argv[i],argv[i],(char*)NULL)==-1) printf("Fail N%i %s\n",i,argv[i]);
		}
		else
		{
			//Ожидаем пока "дочитаем Книгу2"
			wait(&child_status);
		}     
	}
	return 0;
}
